const fs = require('fs-extra')
const path = require('path')
const prettier = require('prettier')
const fetch = require('node-fetch')
const pkginfo = require('pkginfo')(module)

const { getSubgraphBasename } = require('./command-helpers/subgraph')
const { step } = require('./command-helpers/spinner')
const { ascTypeForEthereum, valueTypeForAsc } = require('./codegen/types')
const ABI = require('./abi')
const AbiCodeGenerator = require('./codegen/abi')
const util = require('./codegen/util')
const constant = require('./lib/constant');

const abiEvents = abi =>
  util.disambiguateNames({
    values: abi.data.filter(item => item.get('type') === 'event'),
    getName: event => event.get('name'),
    setName: (event, name) => event.set('_alias', name.replace(/[^a-zA-Z0-9]/g, '')),
  })

  const abiMethods = abi =>
  util.disambiguateNames({
    values: abi.data.filter(item => item.get('type') === 'function' && item.get('stateMutability') !== 'view'  && item.get('stateMutability') !== 'pure'),
    getName: method => method.get('name'),
    setName: (method, name) => method.set('_alias', name.replace(/[^a-zA-Z0-9]/g, '')),
  })

// package.json

const generatePackageJson = ({ subgraphName }) =>
  prettier.format(
    JSON.stringify({
      name: getSubgraphBasename(subgraphName),
      license: 'UNLICENSED',
      scripts: {
        codegen: 'graph codegen',
        build: 'graph build',
        deploy:
          `graph deploy ` +
          `--node https://api.thegraph.com/deploy/ ` +
          `--ipfs https://api.thegraph.com/ipfs/ ` +
          subgraphName,
        'create-local': `graph create --node http://localhost:8020/ ${subgraphName}`,
        'remove-local': `graph remove --node http://localhost:8020/ ${subgraphName}`,
        'deploy-local':
          `graph deploy ` +
          `--node http://localhost:8020/ ` +
          `--ipfs http://localhost:5001 ` +
          subgraphName,
      },
      dependencies: {
        '@graphprotocol/graph-cli': `git+ssh://git@github.com/dapplooker/graph-cli-dlooker.git`,
        '@graphprotocol/graph-ts': `0.18.1`,
      },
    }),
    { parser: 'json' },
  )


  function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }
// Subgraph manifest

const getStartBlock = async(address, network, etherscanApikey) => {

  if(constant.nonEtherscanSupportedNetworks.includes(network)){
    return 0;
  }

  const url = `https://${
    network === 'mainnet' ? 'api' : `api-${network}`
  }.etherscan.io/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&sort=asc${etherscanApikey?'&apikey='+etherscanApikey:''}`;

  let result = await fetch(url)
  let json = await result.json()
  let blockNumber = 0
  // Etherscan returns a JSON object that has a `status`, a `message` and
  // a `result` field. The `status` is '0' in case of errors and '1' in
  // case of success
  if (json.status === '1') {
    blockNumber = json.result.length>0? json.result[0].blockNumber:0;

  }
  console.log(`Start block number for contract ${address} is ${blockNumber}`);
  await sleep(2000);
  return blockNumber;
}

const entityNameByEvent = (eventName, contractName) => `${contractName}${eventName}Event`;
const entityNameByMethod = (methodName, contractName) => `${contractName}${methodName}Call` ;


const generateDataSource = async({ network, fromContracts, etherscanApikey }) => {


    const result = [];
    for(let i =0; i< fromContracts.length; i++) {
      const abi = fromContracts[i].contractAbi;
      const contractName = fromContracts[i].contractName;
      const contractAddress = fromContracts[i].contractAddress;
      const r = `
  - kind: ethereum/contract
    name: ${contractName}
    network: ${network}
    source:
      address: '${contractAddress}'
      abi: ${contractName}
      startBlock: ${await getStartBlock(contractAddress, network, etherscanApikey)}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.2
      language: wasm/assemblyscript
      entities:
        ${abiEvents(abi)
          .map(event => `- ${entityNameByEvent(event.get('_alias'),contractName)}`)
          .join('\n        ')}
        ${abiMethods(abi)
          .map(method => `- ${entityNameByMethod(method.get('_alias'), contractName)}`)
          .join('\n        ')}
      abis:
        - name: ${contractName}
          file: ./abis/${contractName}.json
      ${!shouldIndexCallHandler(network) ? '' :
      `callHandlers:
        ${abiMethods(abi)
          .map(
            method => `
        - function: ${ABI.eventSignature(method)}
          handler: handle${method.get('_alias')}Call`,
          )
          .join('')}`}
      eventHandlers:
        ${abiEvents(abi)
          .map(
            event => `
        - event: ${ABI.eventSignature(event)}
          handler: handle${event.get('_alias')}Event`,
          )
          .join('')}
      file: ./src/${contractName}Mapping.ts`
      result.push(r);
    }

    return result.join('');

}

const generateTemplate = async({network, fromContracts}) => {

  const result = [];
  for (let i = 0; i< fromContracts.length; i++) {
    let templateContracts = fromContracts[i].templateContracts
    for(let j = 0; j< templateContracts.length; j++) {
      const abi = templateContracts[j].contractAbi;
      const contractName = templateContracts[j].contractName;
      const r = `
  - name: ${contractName}
    kind: ethereum/contract
    network: ${network}
    source:
      abi: ${contractName}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.1
      language: wasm/assemblyscript
      entities:
        ${abiEvents(abi)
          .map(event => `- ${entityNameByEvent(event.get('_alias'), contractName)}`)
          .join('\n        ')}
        ${abiMethods(abi)
          .map(method => `- ${entityNameByMethod(method.get('_alias'), contractName)}`)
          .join('\n        ')}
      abis:
        - name: ${contractName}
          file: ./abis/${contractName}.json
      ${!shouldIndexCallHandler(network) ? '' :
      `callHandlers:
        ${abiMethods(abi)
          .map(
            method => `
        - function: ${ABI.eventSignature(method)}
          handler: handle${method.get('_alias')}Call`,
          )
          .join('')}`}
      eventHandlers:
        ${abiEvents(abi)
          .map(
            event => `
        - event: ${ABI.eventSignature(event)}
          handler: handle${event.get('_alias')}Event`,
          )
          .join('')}
      file: ./src/${contractName}Mapping.ts`
      result.push(r);
    }
  }

  return result.join('');

}

const containsTemplateContracts = (fromContracts) => {
  let templateContract = false;
  for (let i = 0; i < fromContracts.length; i++) {
    if (fromContracts[i].templateContracts.length > 0) {
      templateContract = true;
    }
  }
  return templateContract
}

const generateManifest = async ({
  network,
  fromContracts,
  etherscanApikey,
}) =>
  prettier.format(
    `
specVersion: 0.0.1
schema:
  file: ./schema.graphql
dataSources:
  ${await generateDataSource({ network, fromContracts, etherscanApikey })}
${containsTemplateContracts(fromContracts) ?
`templates:
  ${await generateTemplate({network, fromContracts})}
` : ''}
`,
    { parser: 'yaml' },
  )

// Schema

const ethereumTypeToGraphQL = name => {
  let ascType = ascTypeForEthereum(name)
  return valueTypeForAsc(ascType)
}

const getIndexedType = type => {
  if (
    type === 'string' ||
    type === 'bytes' ||
    type === 'tuple' ||
    type.match(/\[[0-9]*\]$/g)
  ) {
    return 'bytes32'
  } else {
    return type
  }
}

const generateField = ({ name, type, indexed }) => {
  let fieldType = indexed ? getIndexedType(type) : type
  return `${name}: ${ethereumTypeToGraphQL(fieldType)}! # ${fieldType}`
}

const generateFields = ({ index, input, parentContext = 'event'}) =>
  input.type == 'tuple'
    ? util
        .unrollTuple({ value: input, path: [input.name || `param${index}`], index })
        .map(({ path, type }) => generateField({ name: path.join('_'), type, parentContext }))
    : [generateField({ name: input.name || (parentContext === 'event' ? `param${index}` : `value${index}`), type: input.type, indexed: (parentContext == 'event' && input.indexed) })]

const generateEventType = (event, contractName) => `type ${entityNameByEvent(event._alias, contractName)} @entity {
      id: ID!
      txHash: Bytes
      fromAddress: Bytes # address
      toAddress: Bytes # address
      valueTransferred: BigInt
      gasUsed: BigInt
      gasPrice: BigInt
      ${event.inputs
        .reduce(
          (acc, input, index) => {
            if(input.name == 'id') {
              return acc
            }
            if(input.name == 'blockTimestamp') {
              acc.shift()
            }
            return acc.concat(generateFields({ input, index }))
          },
          [`blockTimestamp: BigInt! # uint256`],
        )
        .join('\n')}
    }`

    const generateMethodType = (method, contractName) => `type ${entityNameByMethod(method._alias, contractName)} @entity {
      id: ID!
      txHash: Bytes
      fromAddress: Bytes! # address
      toAddress: Bytes # address
      valueTransferred: BigInt
      gasUsed: BigInt
      gasPrice: BigInt
      ${method.inputs
        .reduce(
          (acc, input, index) => {
            if(input.name == 'id') {
              return acc
            }
            if(input.name == 'blockTimestamp') {
              acc.shift()
            }
            return acc.concat(generateFields({ input, index, parentContext: 'method'}))
          },
          [`blockTimestamp: BigInt! # uint256`],
        )
        .join('\n')}
      ${method.outputs
        .reduce(
          (acc, input, index) => acc.concat(generateFields({ input, index, parentContext: 'method' })),
          [],
        )
        .join('\n')}
    }`


const generateSchemas = ({ fromContracts, indexEvents,  network, indexCallHandler }) => {

  let schema = []
  for (let i = 0; i< fromContracts.length; i++) {
    let fromContract = fromContracts[i]
    schema.push(generateSchema(fromContract.contractAbi, fromContract.contractName, indexCallHandler))
    let templateContracts = fromContracts[i].templateContracts
    for(let j = 0; j< templateContracts.length; j++) {
      let templateContract = templateContracts[j]
      schema.push(generateSchema(templateContract.contractAbi, templateContract.contractName, indexCallHandler))
    }
  }
  return schema.join('\n')
}

const generateSchema = (abi, contractName, indexCallHandler) => {
  let events = abiEvents(abi).toJS()
  let methods = abiMethods(abi).toJS();

  const eventSchema = [...events].map(e => generateEventType(e, contractName)).join('\n\n');
  const methodSchema = indexCallHandler ? methods.map(m => generateMethodType(m, contractName)).join('\n\n') : [];
  return prettier.format(
    [eventSchema, methodSchema].join('\n\n'),
    {
      parser: 'graphql',
    },
  )
}

// Mapping

const generateTupleFieldAssignments = ({ keyPath, index, component, context = 'event', field ='params' }) => {
  let name = component.name || `value${index}`
  keyPath = [...keyPath, name]

  let flatName = keyPath.join('_')
  let nestedName = keyPath.join('.')

  return component.type === 'tuple'
    ? component.components.reduce(
        (acc, subComponent, subIndex) =>
          acc.concat(
            generateTupleFieldAssignments({
              keyPath,
              index: subIndex,
              component: subComponent,
            }),
          ),
        [],
      )
    : [`entity.${flatName} = ${context}.${field}.${nestedName}`]
}

const generateFieldAssignment = (path, context = 'event', field = 'params') =>
  `entity.${path.join('_')} = ${context}.${field}.${path.join('.')}`

const generateFieldAssignments = ({ index, input, context = 'event', field = 'params' }) =>
  input.type === 'tuple'
    ? util
        .unrollTuple({ value: input, index, path: [input.name || (context === 'event' ? `param${index}` : `value${index}`)] })
        .map(({ path }) => generateFieldAssignment(path,context, field))
    : generateFieldAssignment([input.name || (context === 'event' ? `param${index}` : `value${index}`)], context, field)

const generateEventFieldAssignments = (event, templateContracts) => {
  let output = [`entity.blockTimestamp = event.block.timestamp`]

  output = event.inputs.reduce(
    (acc, input, index) => {
      if(input.name == 'id') {
        return acc
      }
      if(input.name == 'blockTimestamp') {
        acc.shift()
      }
      return acc.concat(generateFieldAssignments({ input, index }))
    },
    output,
  )
  if (templateContracts) {
    output = templateContracts.reduce(
      (acc, templateContract, index) => {
        if (templateContract.factoryContractEvent == event.name) {
          return acc.concat(`${templateContract.contractName}.create(event.params.${templateContract.factoryContractEventParam})`)
        }
        return acc
      },
      output,
    )
  }
  return output
}

const generateMethodFieldAssignments = method => {
  let output = [`entity.blockTimestamp = call.block.timestamp`];
  output = method.inputs.reduce(
    (acc, input, index) => {
      if(input.name == 'id') {
        return acc
      }
      if(input.name == 'blockTimestamp') {
        acc.shift()
      }
      return acc.concat(generateFieldAssignments({ input, index, context:'call', field: 'inputs' }))
    },
    output,
  );

  output = method.outputs.reduce(
    (acc, input, index) => acc.concat(generateFieldAssignments({ input, index, context:'call', field: 'outputs'})),
    output,
  );

  return output;
}

const toTitleCase = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

const generateEventIndexingHandlers = (events, methods, contract, isTemplateContract) => {

  const contractName = contract.contractName;
  return `
  import { ${events.map(
    event => `${event._alias} as ${event._alias}Event`,
  )}} from '../generated${isTemplateContract ? `/templates` : ''}/${contractName}/${contractName}'
  import { ${methods.map(
    method => `${toTitleCase(method._alias)}Call`,
  )}} from '../generated${isTemplateContract ? `/templates` : ''}/${contractName}/${contractName}'
  import { ${events.map(event => `${entityNameByEvent(event._alias, contractName)} as ${entityNameByEvent(event._alias, contractName)}Schema`)} } from '../generated/schema'
  import { ${methods.map(method => `${entityNameByMethod(method._alias, contractName)} as ${entityNameByMethod(method._alias, contractName)}Schema`)} } from '../generated/schema'
  ${(isTemplateContract || !containsTemplateContracts([contract])) ? '' : `import { ${contract.templateContracts.map(tc => tc.contractName)} } from '../generated/templates'`}

  ${events
    .map(
      event =>
        `
  export function handle${event._alias}Event(event: ${event._alias}Event): void {
    let entity = new ${
      entityNameByEvent(event._alias, contractName)
    }Schema(event.transaction.hash.toHex() + '-' + event.logIndex.toString())
    entity.txHash = event.transaction.hash
    entity.fromAddress = event.transaction.from
    entity.toAddress = event.transaction.to
    entity.valueTransferred =  event.transaction.value
    entity.gasUsed = event.transaction.gasUsed
    entity.gasPrice = event.transaction.gasPrice
    ${generateEventFieldAssignments(event, templateContracts=contract.templateContracts).join('\n')}
    entity.save()
  }
    `,
    )
    .join('\n')}


  ${methods
    .map(
      method =>
        `
  export function handle${method._alias}Call(call: ${toTitleCase(method._alias)}Call): void {
    let id = call.transaction.hash.toHex()
    let entity = new ${entityNameByMethod(method._alias, contractName)}Schema(id);
    entity.txHash = call.transaction.hash
    entity.fromAddress = call.transaction.from
    entity.toAddress = call.transaction.to
    entity.valueTransferred =  call.transaction.value
    entity.gasUsed = call.transaction.gasUsed
    entity.gasPrice = call.transaction.gasPrice
    ${generateMethodFieldAssignments(method).join('\n')}
    entity.save()
  }
    `,
    )
    .join('\n')}
`
}

const generatePlaceholderHandlers = ({ abi, events, contractName }) =>
  `
  import { BigInt } from '@graphprotocol/graph-ts'
  import { ${contractName}, ${events.map(event => event._alias)} }
    from '../generated/${contractName}/${contractName}'
  import { ExampleEntity } from '../generated/schema'

  ${events
    .map((event, index) =>
      index === 0
        ? `
    export function handle${event._alias}(event: ${event._alias}): void {
      // Entities can be loaded from the store using a string ID; this ID
      // needs to be unique across all entities of the same type
      let entity = ExampleEntity.load(event.transaction.from.toHex())

      // Entities only exist after they have been saved to the store;
      // \`null\` checks allow to create entities on demand
      if (entity == null) {
        entity = new ExampleEntity(event.transaction.from.toHex())

        // Entity fields can be set using simple assignments
        entity.count = BigInt.fromI32(0)
      }

      // BigInt and BigDecimal math are supported
      entity.count = entity.count + BigInt.fromI32(1)

      // Entity fields can be set based on event parameters
      ${generateEventFieldAssignments(event)
        .slice(0, 2)
        .join('\n')}

      // Entities can be written to the store with \`.save()\`
      entity.save()

      // Note: If a handler doesn't require existing field values, it is faster
      // _not_ to load the entity from the store. Instead, create it fresh with
      // \`new Entity(...)\`, set the fields that should be updated and save the
      // entity back to the store. Fields that were not set or unset remain
      // unchanged, allowing for partial updates to be applied.

      // It is also possible to access smart contracts from mappings. For
      // example, the contract that has emitted the event can be connected to
      // with:
      //
      // let contract = Contract.bind(event.address)
      //
      // The following functions can then be called on this contract to access
      // state variables and other data:
      //
      // ${
        abi
          .codeGenerator()
          .callableFunctions()
          .isEmpty()
          ? 'None'
          : abi
              .codeGenerator()
              .callableFunctions()
              .map(fn => `- contract.${fn.get('name')}(...)`)
              .join('\n// ')
      }
    }
    `
        : `
export function handle${event._alias}(event: ${event._alias}): void {}
`,
    )
    .join('\n')}`

const generateMapping = ({ indexEvents, indexCallHandler, contract, isTemplateContract}) => {
  let events = abiEvents(contract.contractAbi).toJS()
  let methods = indexCallHandler ? abiMethods(contract.contractAbi).toJS() : []
  return prettier.format(
    generateEventIndexingHandlers(events, methods, contract, isTemplateContract),
    { parser: 'typescript', semi: false },
  )
}

const shouldIndexCallHandler = (network) => {
  return constant.callHandlerSupportedNetworks.includes(network);
}

const generateScaffold = async (
  {
    fromContracts,
    network,
    subgraphName,
    indexEvents,
    etherscanApikey,
  },
  spinner,
) => {
  step(spinner, 'Generate subgraph from ABI')

  let packageJson = generatePackageJson({ subgraphName })
  let manifest = await generateManifest({
    fromContracts,
    network,
    etherscanApikey,
  })

  let schema = generateSchemas({
    fromContracts,
    indexEvents,
    network,
    indexCallHandler: shouldIndexCallHandler(network)
  })

  const mappingMap = {};
  const abiMap = {};

  for(let i=0; i< fromContracts.length; i++) {

    mappingMap[`${fromContracts[i].contractName}Mapping.ts`] = generateMapping({
       indexEvents,
       contract: fromContracts[i],
       isTemplateContract: false,
       indexCallHandler: shouldIndexCallHandler(network),
    });
    abiMap[`${fromContracts[i].contractName}.json`] = prettier.format(JSON.stringify(fromContracts[i].contractAbi.data), {
      parser: 'json',
    });

    let templateContracts = fromContracts[i].templateContracts;
    for (let j=0; j < templateContracts.length; j++) {
      mappingMap[`${templateContracts[j].contractName}Mapping.ts`] = generateMapping({
        indexEvents,
        contract: templateContracts[j],
        isTemplateContract: true,
        indexCallHandler: shouldIndexCallHandler(network),
      });
      abiMap[`${templateContracts[j].contractName}.json`] = prettier.format(JSON.stringify(templateContracts[j].contractAbi.data), {
        parser: 'json',
      });
    }

  }

  return {
    'package.json': packageJson,
    'subgraph.yaml': manifest,
    'schema.graphql': schema,
    src: mappingMap,
    abis: abiMap,
  }
}

const writeScaffoldDirectory = async (scaffold, directory, spinner) => {
  // Create directory itself
  fs.mkdirsSync(directory)

  Object.keys(scaffold).forEach(basename => {
    let content = scaffold[basename]
    let filename = path.join(directory, basename)

    // Write file or recurse into subdirectory
    if (typeof content === 'string') {
      fs.writeFileSync(filename, content, { encoding: 'utf-8' })
    } else {
      writeScaffoldDirectory(content, path.join(directory, basename), spinner)
    }
  })
}

const writeScaffold = async (scaffold, directory, spinner) => {
  step(spinner, `Write subgraph to directory`)
  await writeScaffoldDirectory(scaffold, directory, spinner)
}

module.exports = {
  ...module.exports,
  abiEvents,
  generateEventFieldAssignments,
  generateManifest,
  generateMapping,
  generateScaffold,
  generateSchema,
  writeScaffold,
}
